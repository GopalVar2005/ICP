class Solution {
    public int rob(int[] nums) {
        int n=nums.length;
        int[] dp=new int[n];
        Arrays.fill(dp, -1);
        return TD(nums, n-1, dp);
    }
    public int TD(int[] nums, int n, int[] dp)
    {
        if(n<0)
        {
            return 0;
        }
        if(n==0)
        {
            return nums[0];
        }
        if(dp[n]!=-1)
        {
            return dp[n];
        }
        dp[n]=Math.max(TD(nums, n-2, dp)+nums[n], TD(nums,n-1, dp));
        return dp[n];
    }
    // public int rec(int[] nums, int n)
    // {
    //     if(n<0)
    //     {
    //         return 0;
    //     }
    //     if(n==0)
    //     {
    //         return nums[0];
    //     }
    //     return Math.max(rec(nums, n-2)+nums[n], rec(nums,n-1));
    // }
}
| Complexity Type      | Big-O    | Explanation                         |
| -------------------- | -------- | ----------------------------------- |
| **Time Complexity**  | **O(n)** | Each subproblem (index) solved once |
| **Space Complexity** | **O(n)** | DP array + recursion call stack     |

Example 1:

Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
Example 2:

Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
